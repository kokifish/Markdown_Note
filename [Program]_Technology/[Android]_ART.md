# ART

> android 5.0 开始

Dalvik虚拟机执行的是DEX字节码，ART虚拟机执行的是本地机器码。ART虚拟机在app_process进程(zygote)中启动



- .vdex：包含APK的未压缩DEX代码，以及一些额外的元数据以加快验证。
- .odex：包含APK中方法的AOT编译代码。
- .art (optional)：包含APK中列出的一些字符串和类的ART内部表示，用于加快应用程序的启动



- `intrinsics_arm64.cc`: 主要负责 ARM64 架构的内联函数（Intrinsics）的实现。内联函数（Intrinsics）是一种特殊的函数，它们在编译时被直接插入到调用它们的代码中，而不是通过常规的函数调用机制来调用。这样可以减少函数调用的开销，并允许编译器进行更多的优化。例如，编译器可以看到内联函数的实现，并据此进行更好的代码优化。在 ART 中，内联函数用于实现一些常用的、性能关键的 Java 方法。例如，`Math.sin` 或 `String.length` 可能会被实现为内联函数。这样，当这些方法被调用时，它们的实现可以直接插入到调用它们的代码中，从而提高运行速度。`intrinsics_arm64.cc` 文件包含了 ARM64 架构的内联函数的实现。这些实现通常会使用 ARM64 的汇编语言，以便直接控制硬件并实现最佳性能。这个文件的代码会被 ART 的即时编译器（JIT）和前端优化编译器（AOT）使用，以生成高效的机器代码。

- `DoResolveType` 是 Android Runtime (ART) 中的一个函数，它的主要任务是解析类型引用，将其转换为具体的类对象。这个函数在类加载和字节码验证过程中起着关键作用。

  在 Java 中，类和接口的名称在编译时被编码为字符串，并存储在类文件的常量池中。这些字符串被称为类型引用。当 JVM 加载和链接一个类时，它需要将这些类型引用解析为实际的类对象。这就是 `DoResolveType` 函数的任务。

  具体来说，`DoResolveType` 函数接受一个类型引用和一个类加载器作为参数。它首先检查类型引用是否已经被解析。如果已经解析，那么它直接返回对应的类对象。否则，它使用类加载器加载类型引用对应的类，并将结果存储在一个缓存中，以便下次解析同一个类型引用时可以直接使用。

  `DoResolveType` 函数在 ART 的类加载和链接阶段中起着关键作用。在这个阶段，ART 需要加载类文件，验证字节码，解析类型引用，以及执行其他任务以准备执行 Java 代码。`DoResolveType` 是这个过程中的一个重要步骤，它确保了类型引用可以被正确地解析为类对象。

  在更大的范围内，`DoResolveType` 是 ART 实现 Java 语言规范的一部分。Java 语言规范定义了类加载和链接的过程，包括类型引用的解析。通过实现这些规范，ART 可以确保它可以正确地执行任何有效的 Java 代码。



## Android ClassLoader

- 双亲委派机制
- 全盘负责委托机制
  - 加载.class: 递归逐级向上委托给父加载器ParentClassLoader加载。如果加载过了则不再加载；如果父加载器没加载过，则继续委托给父加载器去加载直到链路顶级，顶级classLoader如果没加载过则尝试加载。加载失败，则逐级向下交还调用者(下级ClassLoader)来加载


Android中使用的类加载器主要包括PathClassLoader和DexClassLoader两个，这两个加载器在Android8以后已经完全一样了，他们都是继承自BaseClassLoader

- 防止同一个.class文件重复加载
- 对于任意一个类确保在JVM中的唯一性。一个类在JVM中的唯一性是由加载它的ClassLoader和这个类的全名共同确立的
- 保证系统类.class文件不能被篡改，通过双亲委派机制可以保证系统类的加载逻辑不会被篡改



## how to debug

```bash
MaybeOverrideVerbosity() 里设置log开关，可以进行开启

```

### lldb debug

> https://apt.llvm.org/

```bash
adb push lldb-server /data/local/tmp/
adb shell chmod +x /data/local/tmp/lldb-server
# guest(android):
adb shell
su
cd /data/local/tmp  # 一定要cd过去执行 否则会报 Read-only file system
./lldb-server platform --listen "*:2222" --server

# host(android avd):
adb forward tcp:2222 tcp:2222
lldb-16
platform select remote-android
platform connect connect://localhost:2222

attach installd # ps -ef | grep installd # 目标调试进程
settings set target.process.follow-fork-mode child
c
br art::mirror::Class::GetDescriptor
# im loo -n GetDescriptor # 0x0000000000530238+60(0x3c)
breakpoint set -a 0x530274 -s libart.so # 相对于libart.so的偏移地址
breakpoint modify --auto-continue true 1

breakpoint command add 1.1
> register read
> bt
> DONE


im loo -n GetDescriptor
```

```bash
script help(lldb.SBFrame) # show the full API that is exposed for that class
```





## class

> https://www.jianshu.com/p/d0b0c1bfbcf6 安卓9的分析，有的函数进行了更名和实现重构
>
> https://zhuanlan.zhihu.com/p/159207395

#### Class

```cpp
// art/runtime/mirror/class.h
// C++ mirror of java.lang.Class
class MANAGED Class final : public Object {
 public:
  MIRROR_CLASS("Ljava/lang/Class;");
  // ...... //
  // Defining class loader, or null for the "bootstrap" system loader.
  HeapReference<ClassLoader> class_loader_;
  
  // For array classes, the component class object for instanceof/checkcast
  // (for String[][][], this will be String[][]). null for non-array classes.
  HeapReference<Class> component_type_;

  // DexCache of resolved constant pool entries (will be null for classes generated by the
  // runtime such as arrays and primitive classes).
  HeapReference<DexCache> dex_cache_; // 该类缓存在哪个DexCache对象中

  // Extraneous class data that is not always needed. This field is allocated lazily and may
  // only be set with 'this' locked. This is synchronized on 'this'.
  // TODO(allight) We should probably synchronize it on something external or handle allocation in
  // some other (safe) way to prevent possible deadlocks.
  HeapReference<ClassExt> ext_data_;

  // The interface table (iftable_) contains pairs of a interface class and an array of the
  // interface methods. There is one pair per interface supported by this class.  That means one
  // pair for each interface we support directly, indirectly via superclass, or indirectly via a
  // superinterface.  This will be null if neither we nor our superclass implement any interfaces.
  //
  // Why we need this: given "class Foo implements Face", declare "Face faceObj = new Foo()".
  // Invoke faceObj.blah(), where "blah" is part of the Face interface.  We can't easily use a
  // single vtable.
  //
  // For every interface a concrete class implements, we create an array of the concrete vtable_
  // methods for the methods in the interface.
  HeapReference<IfTable> iftable_; // 该类所实现或从父类那继承得到的接口类里相关的函数

  // Descriptor for the class such as "java.lang.Class" or "[C". Lazily initialized by ComputeName
  HeapReference<String> name_; // 对应java的class type name

  // The superclass, or null if this is java.lang.Object or a primitive type.
  //
  // Note that interfaces have java.lang.Object as their
  // superclass. This doesn't match the expectations in JNI
  // GetSuperClass or java.lang.Class.getSuperClass() which need to
  // check for interfaces and return null.
  HeapReference<Class> super_class_; // 父类？

  // Virtual method table (vtable), for use by "invoke-virtual".  The vtable from the superclass is
  // copied in, and virtual methods from our class either replace those from the super or are
  // appended. For abstract classes, methods may be created in the vtable that aren't in
  // virtual_ methods_ for miranda methods.
  HeapReference<PointerArray> vtable_; // 来自父类及本类的virtual函数表 虚表 // 保存在本类中定义的direct、virtual及拷贝过来的方法

  // instance fields
  //
  // These describe the layout of the contents of an Object.
  // Note that only the fields directly declared by this class are
  // listed in ifields; fields declared by a superclass are listed in
  // the superclass's Class.ifields.
  //
  // ArtFields are allocated as a length prefixed ArtField array, and not an array of pointers to
  // ArtFields.
  uint64_t ifields_; // 非静态成员变量

  // Pointer to an ArtMethod length-prefixed array. All the methods where this class is the place
  // where they are logically defined. This includes all private, static, final and virtual methods
  // as well as inherited default methods and miranda methods.
  //
  // The slice methods_ [0, virtual_methods_offset_) are the direct (static, private, init) methods
  // declared by this class.
  //
  // The slice methods_ [virtual_methods_offset_, copied_methods_offset_) are the virtual methods
  // declared by this class.
  //
  // The slice methods_ [copied_methods_offset_, |methods_|) are the methods that are copied from
  // interfaces such as miranda or default methods. These are copied for resolution purposes as this
  // class is where they are (logically) declared as far as the virtual dispatch is concerned.
  //
  // Note that this field is used by the native debugger as the unique identifier for the type.
  uint64_t methods_; // 直接方法/virtual方法/Miranda Methods // Miranda Methods在LinkClass阶段动态拷贝而来

  // Static fields length-prefixed array.
  uint64_t sfields_; // 静态成员变量

  // Access flags; low 16 bits are defined by VM spec.
  uint32_t access_flags_;

  // Class flags to help speed up visiting object references.
  uint32_t class_flags_; // 虚拟机内部使用的用于加速的

  // Total size of the Class instance; used when allocating storage on gc heap.
  // See also object_size_.
  uint32_t class_size_; // 当分配一个对象时，用于说明这个类对象所需内存大小

  // Tid used to check for recursive <clinit> invocation.
  pid_t clinit_thread_id_;

 	// ClassDef index in dex file, -1 if no class definition such as an array.
  // TODO: really 16bits
  int32_t dex_class_def_idx_;

  // Type index in dex file.
  // TODO: really 16bits
  int32_t dex_type_idx_; // 本类在dex文件里type_ids中的索引

  // Number of instance fields that are object refs.
  uint32_t num_reference_instance_fields_; // 引用类型的非静态成员变量个数

  // Number of static fields that are object refs,
  uint32_t num_reference_static_fields_; // 引用类型的静态成员变量个数

  // Total object size; used when allocating storage on gc heap.
  // (For interfaces and abstract classes this will be zero.)
  // See also class_size_.
  uint32_t object_size_; // 实例对象的内存大小，interface/abstract class为0

  // Aligned object size for allocation fast path. The value is max uint32_t if the object is
  // uninitialized or finalizable. Not currently used for variable sized objects.
  uint32_t object_size_alloc_fast_path_;

  // The lower 16 bits contains a Primitive::Type value. The upper 16
  // bits contains the size shift of the primitive type.
  uint32_t primitive_type_;

  // Bitmap of offsets of ifields.
  uint32_t reference_instance_offsets_;

  // See the real definition in subtype_check_bits_and_status.h
  // typeof(status_) is actually SubtypeCheckBitsAndStatus.
  uint32_t status_; // 类状态

  // The offset of the first virtual method that is copied from an interface. This includes miranda,
  // default, and default-conflict methods. Having a hard limit of ((2 << 16) - 1) for methods
  // defined on a single class is well established in Java so we will use only uint16_t's here.
  uint16_t copied_methods_offset_;

  // The offset of the first declared virtual methods in the methods_ array.
  uint16_t virtual_methods_offset_;
  
  // 隐含成员变量:
  // The following data exist in real class objects.
  // Embedded Imtable, for class object that's not an interface, fixed size.
  // ImTableEntry embedded_imtable_[0]; // 如果类可实例化，则存在这个变量。方便快速找到接口方法
  // Embedded Vtable, for class object that's not an interface, variable size.
  // VTableEntry embedded_vtable_[0];   // 如果类可实例化，则只存在embedded_vtable_，否则vtable_
  // Static fields, variable size.
  // uint32_t fields_[0];
```

```cpp
art/runtime/class_status.h // 解释了status各个状态的含义 注释中包含对关键函数的解释
```

#### ArtField

```cpp
// art/runtime/art_field.h
// C++ mirror of java.lang.reflect.ArtField
class ArtField final {
  // ...... //
  GcRoot<mirror::Class> declaring_class_;

  uint32_t access_flags_ = 0;

  // Dex cache index of field id
  uint32_t field_dex_idx_ = 0;

  // Offset of field within an instance or in the Class' static fields
  uint32_t offset_ = 0;
```

#### ArtMethod

```cpp
// art/runtime/art_method.h
// C++ mirror of java.lang.reflect.Method and java.lang.reflect.Constructor
class ArtMethod final {
 protected:
  // Field order required by test "ValidateFieldOrderOfJavaCppUnionClasses".
  // The class we are a part of.
  GcRoot<mirror::Class> declaring_class_;

  // Access flags; low 16 bits are defined by spec.
  // Getting and setting this flag needs to be atomic when concurrency is
  // possible, e.g. after this method's class is linked. Such as when setting
  // verifier flags and single-implementation flag.
  std::atomic<std::uint32_t> access_flags_;

  /* Dex file fields. The defining dex file is available via declaring_class_->dex_cache_ */

  // Index into method_ids of the dex file associated with this method.
  uint32_t dex_method_index_;

  /* End of dex file fields. */

  // Entry within a dispatch table for this method. For static/direct methods the index is into
  // the declaringClass.directMethods, for virtual methods the vtable and for interface methods the
  // ifTable.
  uint16_t method_index_; // 与class类管理成员函数有关 // 如果这个ArtMethod对应的是一个static或direct函数，则method_index_是指向定义它的类的methods_中的索引 // 如果这个ArtMethod是virtual函数，则method_index_是指向它的VTable中的索引

  union {
    // Non-abstract methods: The hotness we measure for this method. Not atomic,
    // as we allow missing increments: if the method is hot, we will see it eventually.
    uint16_t hotness_count_; // 热度，与JIT有关
    // Abstract methods: IMT index.
    uint16_t imt_index_; // Interface Method Table 索引
  };

  // Fake padding field gets inserted here.

  // Must be the last fields in the method.
  struct PtrSizedFields {
    // Depending on the method type, the data is
    //   - native method: pointer to the JNI function registered to this method
    //                    or a function to resolve the JNI function,
    //   - resolution method: pointer to a function to resolve the method and
    //                        the JNI function for @CriticalNative.
    //   - conflict method: ImtConflictTable,
    //   - abstract/interface method: the single-implementation if any,
    //   - proxy method: the original interface method or constructor,
    //   - other methods: during AOT the code item offset, at runtime a pointer
    //                    to the code item.
    void* data_;

    // Method dispatch from quick compiled code invokes this pointer which may cause bridging into
    // the interpreter.
    void* entry_point_from_quick_compiled_code_; // java方法入口函数地址
  } ptr_sized_fields_;
```

#### DexCache

```cpp
// art/runtime/mirror/dex_cache.h
// C++ mirror of java.lang.DexCache.
class MANAGED DexCache final : public Object {
 public:
  MIRROR_CLASS("Ljava/lang/DexCache;");

  HeapReference<ClassLoader> class_loader_;
  HeapReference<String> location_; //dex文件对应的路径

  uint64_t dex_file_;              // DexFile*，指向关联的dex文件
  /* ArtField**指向ArtField*数组，成员类型为ArtField*。改数组存储了一个dex文件中定义的所有类的成    
  员变量。另外，只有那些解析后的ArtField对象才会存到这个数组里。该字段和dex文件里的field_ids
  数组有关。  */
  uint64_t preresolved_strings_;
  uint64_t resolved_call_sites_;
  uint64_t resolved_fields_;
  /* ArtMethod**指向ArtMethod*数组，成员类型为ArtMethod*。改数组存储了一个dex文件中定义的所
  有类的成员变量。另外，只有那些解析后的ArtMethod对象才会存到这个数组里。该字段和dex文件里
  的method_ids数组有关。  */
  uint64_t resolved_method_types_;
  uint64_t resolved_methods_;
  /*实际为GcRoot<Class>*，指向GcRoot<Class>数组，成员类型为GcRoot<Class>(本质上是
  mirror::Class*)。它存储该dex文件里使用的数据类型信息数组。该字段和dex文件里的type_ids数组有
  关。  */
  uint64_t resolved_types_;         // 例如：Ljava/lang/String
  /*实际为GcRoot<String>*，指向GcRoot<String>数组，成员类型为GcRoot<String>(本质上是
  mirror::String*)。它存储该dex文件里使用的字符串信息数组。该字段和dex文件里的string_ids数组
  有关。  */
  uint64_t strings_;

  // 对应上面的数组的长度
  uint32_t num_preresolved_strings_;    // Number of elements in the preresolved_strings_ array.
  uint32_t num_resolved_call_sites_;    // Number of elements in the call_sites_ array.
  uint32_t num_resolved_fields_;        // Number of elements in the resolved_fields_ array.
  uint32_t num_resolved_method_types_;  // Number of elements in the resolved_method_types_ array.
  uint32_t num_resolved_methods_;       // Number of elements in the resolved_methods_ array.
  uint32_t num_resolved_types_;         // Number of elements in the resolved_types_ array.
  uint32_t num_strings_;                // Number of elements in the strings_ array.
};
```





## Progress

> **@Inherited** 指定子类可继承父类的注解，只能是类上的注解，方法和字段的注解不能继承。即如果父类上的注解是@Inherited修饰的就能被子类继承

```cpp
FindClass // 根据类的字符串名搜索一个类。如果没有的话，可能触发类的加载和链接
    ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self, const char* desc, Handle<mirror::ClassLoader> class_loader)
  ->LookupClass  // Find the class in the loaded classes table
  ->DefineClass  // 定义一个cpp class？// 核心功能
    ->SetupClass // kStatusNotReady to kStatusIdx
  		->SetClass
      ->SetAccessFlagsDuringLinking // 设置链接时访问标志？
      ->SetClassLoader // 设置该类的加载器对象
      ->SetStatus      // 设置kclass的状态为 ClassStatus::kIdx
      ->SetDexClassDefIndex
      ->SetDexTypeIndex
    ->ClassLinker::LoadClass // populates with Class with information from the DexFile // 从dex中提取class_data信息
      // 用accessor.VisitFieldsAndMethods访问器，传递函数指针，分别加载 1.静态field 2.非静态field 3.直接method 4.virtual method
      ->LoadField  // 加载 静态/非静态field 
      ->LoadMethod // 加载 method // 加载method prototype，包括finalize, <init>, @FastNative, @CriticalNative. 配置oat flag
      ->LinkCode   // 处理LoadMethod出参art_method // 很核心很硬核，目测应该是把java code分不同调用范式转换成cpp code？
    ->LoadSuperAndInterfaces
    // 此时目标class的信息从dex文件对应的class_def结构体及其他相关结构体已经提取并转换为c++ Class实例，同时该Class实例中代表本类成员变量和成员函数的信息被分别创建为ArtField和ArtMethod对象，并做相应设置。即c++ Class的sfields_ ifields_ methods_ 已经被设置好了
    ->LinkClass // 链接link，
      ->LinkMethods // 处理该类包含的方法：
      ->LinkInstanceFields // 处理成员变量：
      ->LinkStaticFields // 处理静态成员变量：
      ->CreateReferenceInstanceOffsets // 处理Class的reference_instance_offsets_成员变量 // 提供了一种快速访问类非静态引用变量的方法。如果某个位上为1，说明对应的位置上有一个非静态引用类型变量，否则为0。如果超过32个非静态引用对象，放弃优化，沿着派生关系向上对引用型变量查找
```



## assembly: GetDescriptor

```cpp
  // For array classes, the component class object for instanceof/checkcast
  // (for String[][][], this will be String[][]). null for non-array classes.
  HeapReference<Class> component_type_; // art/runtime/mirror/class.h

kVerifyFlags // 标志位集合，用于在类加载和字节码验证过程中控制各种选项。例如，它可能包含一个标志来指示是否应执行更严格的字节码验证，或者是否应允许加载未知的类。具体的标志和它们的含义可能会因 ART 的版本和配置而有所不同
GetComponentType // 获取数组类的组件类型。在 Java 中，每个数组类都有一个组件类型，即数组元素的类型。例如，对于 int[] 类型的数组，其组件类型是 int。GetComponentType 方法返回一个表示组件类型的 Class 对象
IsArrayClass // 检查一个类是否是数组类。在 Java 中，数组是一种特殊的类，有自己的类对象（例如 int[].class）。IsArrayClass 方法接受一个 Class 对象作为参数，如果这个类是数组类，那么返回 true，否则返回 false
```

```assembly
libart.so`art::mirror::Class::GetDescriptor:
0x7ad4130238: 0xd101c3ff  sub    sp, sp, #0x70
0x7ad413023c: 0xa9047bfd  stp    x29, x30, [sp, #0x40] ; 将寄存器对存储到堆栈
0x7ad4130240: 0xa90557f6  stp    x22, x21, [sp, #0x50]
0x7ad4130244: 0xa9064ff4  stp    x20, x19, [sp, #0x60]
0x7ad4130248: 0x910103fd  add    x29, sp, #0x40   ; 将0x40加到堆栈指针（sp），并将结果存储在x29中。这通常是为了设置一个新的堆栈帧
0x7ad413024c: 0xd53bd055  mrs    x21, TPIDR_EL0   ; 将系统寄存器TPIDR_EL0的值移动到x21
0x7ad4130250: 0xf94016a8  ldr    x8, [x21, #0x28] ; x8=TPIDR_EL0+0x28 读取canary值
0x7ad4130254: 0xaa0103f3  mov    x19, x1          ; x19= string* storage
0x7ad4130258: 0xaa1f03f4  mov    x20, xzr         ; x20=0; size_t dim = 0u;
0x7ad413025c: 0xf81f83a8  stur   x8, [x29, #-0x8] ; 保存canary到栈上对应位置
0x7ad4130260: 0xb9400c08  ldr    w8, [x0, #0xc]   ; # Class.component_type_? # here, x0=this # this+0xc=component_type_
0x7ad4130264: 0x340000e8  cbz    w8, 0x7ad4130280 ; <+72> [inlined] std::__1::__atomic_base<int, false>::load(std::__1::memory_order) const at atomic:926:17 ; 如果寄存器w8中的值为零，跳过whilek; lass->IsArrayClass()?
0x7ad4130268: 0x91003008  add    x8, x0, #0xc     ; x8=this+0xc=component_type_
0x7ad413026c: 0xb9400100  ldr    w0, [x8]         ; while { # w0= ObjPtr<Class> *(this->component_type_)
0x7ad4130270: 0x91000694  add    x20, x20, #0x1   ; ++dim;
# klass = klass->GetComponentType<kDefaultVerifyFlags, kWithoutReadBarrier>(); # CRASH!
0x7ad4130274:!0xb9400c09  ldr    w9, [x0, #0xc]   ; CRASH! # w9 = p_class->component_type_
0x7ad4130278: 0x91003008  add    x8, x0, #0xc     ; x8=addr of (this->component_type_)
0x7ad413027c: 0x35ffff89  cbnz   w9, 0x7ad413026c ; } <+52> [inlined] std::__1::__atomic_base<unsigned int, false>::load(std::__1::memory_order) const at atomic:926:17
0x7ad4130280: 0xb9404008  ldr    w8, [x0, #0x40]
0x7ad4130284: 0x37900128  tbnz   w8, #0x12, 0x7ad41302a8 ; <+112> [inlined] std::__1::__atomic_base<unsigned int, false>::load(std::__1::memory_order) const at atomic:926:17
0x7ad4130288: 0xb9406808  ldr    w8, [x0, #0x68]
0x7ad413028c: 0x72003d1f  tst    w8, #0xffff
0x7ad4130290: 0x540004a0  b.eq   0x7ad4130324     ; <+236> [inlined] std::__1::__atomic_base<unsigned int, false>::load(std::__1::memory_order) const at atomic:926:17
0x7ad4130294: 0xb9406808  ldr    w8, [x0, #0x68]
0x7ad4130298: 0x12003d00  and    w0, w8, #0xffff
0x7ad413029c: 0x97f6107c  bl     0x7ad3eb448c     ; art::Primitive::Descriptor at primitive.h:112
0x7ad41302a0: 0xaa0003e1  mov    x1, x0
0x7ad41302a4: 0x14000034  b      0x7ad4130374     ; <+316> at class.cc:1143:9
0x7ad41302a8: 0xb9401c00  ldr    w0, [x0, #0x1c]
0x7ad41302ac: 0x910023e8  add    x8, sp, #0x8
0x7ad41302b0: 0x910023f6  add    x22, sp, #0x8
0x7ad41302b4: 0x94005197  bl     0x7ad4144910  ; art::mirror::String::ToModifiedUtf8 at string.cc:268
0x7ad41302b8: 0x394023e8  ldrb   w8, [sp, #0x8]
0x7ad41302bc: 0xf9400fe9  ldr    x9, [sp, #0x18]
0x7ad41302c0: 0xb24002ca  orr    x10, x22, #0x1
0x7ad41302c4: 0x7200011f  tst    w8, #0x1
0x7ad41302c8: 0x9a890140  csel   x0, x10, x9, eq
0x7ad41302cc: 0x910083e8  add    x8, sp, #0x20
0x7ad41302d0: 0x940ab3b4  bl     0x7ad43dd1a0  ; symbol stub for: art::DotToDescriptor(char const*)
0x7ad41302d4: 0x39400268  ldrb   w8, [x19]
0x7ad41302d8: 0x36000108  tbz    w8, #0x0, 0x7ad41302f8  ; <+192> [inlined] std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::__move_assign(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>&, std::__1::integral_constant<bool, true>) + 36 at string:2304:18
0x7ad41302dc: 0xf9400a68  ldr    x8, [x19, #0x10]
0x7ad41302e0: 0x3900011f  strb   wzr, [x8]
0x7ad41302e4: 0x39400268  ldrb   w8, [x19]
0x7ad41302e8: 0xf900067f  str    xzr, [x19, #0x8]
0x7ad41302ec: 0x36000068  tbz    w8, #0x0, 0x7ad41302f8  ; <+192> [inlined] std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::__move_assign(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>&, std::__1::integral_constant<bool, true>) + 36 at string:2304:18
0x7ad41302f0: 0xf9400a60  ldr    x0, [x19, #0x10]
0x7ad41302f4: 0x940aaf57  bl     0x7ad43dc050  ; symbol stub for: operator delete(void*)
0x7ad41302f8: 0xf9401be8  ldr    x8, [sp, #0x30]
0x7ad41302fc: 0x3dc00be0  ldr    q0, [sp, #0x20]
0x7ad4130300: 0xf9000a68  str    x8, [x19, #0x10]
0x7ad4130304: 0x3d800260  str    q0, [x19]
0x7ad4130308: 0x394023e8  ldrb   w8, [sp, #0x8]
0x7ad413030c: 0xa902ffff  stp    xzr, xzr, [sp, #0x28]
0x7ad4130310: 0xf90013ff  str    xzr, [sp, #0x20]
0x7ad4130314: 0x36000368  tbz    w8, #0x0, 0x7ad4130380  ; <+328> at class.cc:1148:12
0x7ad4130318: 0xf9400fe0  ldr    x0, [sp, #0x18]
0x7ad413031c: 0x940aaf4d  bl     0x7ad43dc050  ; symbol stub for: operator delete(void*)
0x7ad4130320: 0x14000018  b      0x7ad4130380  ; <+328> at class.cc:1148:12
0x7ad4130324: 0xb9401008  ldr    w8, [x0, #0x10]
0x7ad4130328: 0xf9400908  ldr    x8, [x8, #0x10]
0x7ad413032c: 0xb9405409  ldr    w9, [x0, #0x54]
0x7ad4130330: 0xf9402d0a  ldr    x10, [x8, #0x58]
0x7ad4130334: 0x92403d29  and    x9, x9, #0xffff
0x7ad4130338: 0xb8697949  ldr    w9, [x10, x9, lsl #2]
0x7ad413033c: 0x3100053f  cmn    w9, #0x1
0x7ad4130340: 0x54000180  b.eq   0x7ad4130370              ; <+312> at leb128.h
0x7ad4130344: 0xf940290a  ldr    x10, [x8, #0x50]
0x7ad4130348: 0xf9400d08  ldr    x8, [x8, #0x18]
0x7ad413034c: 0xb8697949  ldr    w9, [x10, x9, lsl #2]
0x7ad4130350: 0x8b090108  add    x8, x8, x9
0x7ad4130354: 0xaa0803e1  mov    x1, x8
0x7ad4130358: 0x38c01429  ldrsb  w9, [x1], #0x1
0x7ad413035c: 0x36f800c9  tbz    w9, #0x1f, 0x7ad4130374  ; <+316> at class.cc:1143:9
0x7ad4130360: 0x39c00509  ldrsb  w9, [x8, #0x1]
0x7ad4130364: 0x37f80369  tbnz   w9, #0x1f, 0x7ad41303d0  ; <+408> [inlined] art::DecodeUnsignedLeb128(unsigned char const**) at leb128.h:40:13
0x7ad4130368: 0x91000901  add    x1, x8, #0x2
0x7ad413036c: 0x14000002  b      0x7ad4130374  ; <+316> at class.cc:1143:9
0x7ad4130370: 0xaa1f03e1  mov    x1, xzr
0x7ad4130374: 0xb40001b4  cbz    x20, 0x7ad41303a8  ; <+368> at string
0x7ad4130378: 0xaa1303e0  mov    x0, x19
0x7ad413037c: 0x940aaf95  bl     0x7ad43dc1d0  ; symbol stub for: std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::assign(char const*)
0x7ad4130380: 0x52800b63  mov    w3, #0x5b     ; 0x5b='['
0x7ad4130384: 0xaa1303e0  mov    x0, x19
0x7ad4130388: 0xaa1f03e1  mov    x1, xzr
0x7ad413038c: 0xaa1403e2  mov    x2, x20
0x7ad4130390: 0x940ab4fc  bl     0x7ad43dd780  ; symbol stub for: std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::insert(unsigned long, unsigned long, char); storage->insert(0u, dim, '[');
0x7ad4130394: 0x39400268  ldrb   w8, [x19]
0x7ad4130398: 0x37000068  tbnz   w8, #0x0, 0x7ad41303a4  ; <+364> [inlined] std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::__get_long_pointer() const at string:1509:34; storage->c_str();
0x7ad413039c: 0x91000661  add    x1, x19, #0x1
0x7ad41303a0: 0x14000002  b      0x7ad41303a8  ; <+368> at string
0x7ad41303a4: 0xf9400a61  ldr    x1, [x19, #0x10]
0x7ad41303a8: 0xf94016a8  ldr    x8, [x21, #0x28]
0x7ad41303ac: 0xf85f83a9  ldur   x9, [x29, #-0x8]
0x7ad41303b0: 0xeb09011f  cmp    x8, x9
0x7ad41303b4: 0x54000221  b.ne   0x7ad41303f8  ; <+448> at class.cc ; to __stack_chk_fail
0x7ad41303b8: 0xa9464ff4  ldp    x20, x19, [sp, #0x60]
0x7ad41303bc: 0xa94557f6  ldp    x22, x21, [sp, #0x50]
0x7ad41303c0: 0xa9447bfd  ldp    x29, x30, [sp, #0x40]
0x7ad41303c4: 0xaa0103e0  mov    x0, x1
0x7ad41303c8: 0x9101c3ff  add    sp, sp, #0x70
0x7ad41303cc: 0xd65f03c0  ret
0x7ad41303d0: 0x39c00909  ldrsb  w9, [x8, #0x2]
0x7ad41303d4: 0x37f80069  tbnz   w9, #0x1f, 0x7ad41303e0   ; <+424> [inlined] art::DecodeUnsignedLeb128(unsigned char const**) + 16 at leb128.h:43:15
0x7ad41303d8: 0x91000d01  add    x1, x8, #0x3
0x7ad41303dc: 0x17ffffe6  b      0x7ad4130374              ; <+316> at class.cc:1143:9
0x7ad41303e0: 0x39c00d09  ldrsb  w9, [x8, #0x3]
0x7ad41303e4: 0x7100013f  cmp    w9, #0x0
0x7ad41303e8: 0x52800089  mov    w9, #0x4
0x7ad41303ec: 0x9a89a529  cinc   x9, x9, lt
0x7ad41303f0: 0x8b090101  add    x1, x8, x9
0x7ad41303f4: 0x17ffffe0  b      0x7ad4130374              ; <+316> at class.cc:1143:9
0x7ad41303f8: 0x940aaf2e  bl     0x7ad43dc0b0              ; symbol stub for: __stack_chk_fail
```



# cmd-line

```bash
# cmdline for android 11 5.4 kernel
# Step-0: check aosp source: TARGET_KERNEL_USE := 5.4
# Step-1: Build/upload kernel/a11
clear; BUILD_CONFIG=common-modules/virtual-device/build.config.goldfish.aarch64 build/build.sh -j$(nproc --all) && rm /data/a11/gsi/prebuilts/qemu-kernel/arm64/5.4/ko/* && cp out/android11-5.4/dist/*.ko /data/a11/gsi/prebuilts/qemu-kernel/arm64/5.4/ko/ && cp out/android11-5.4/dist/Image.gz Image.gz && cd /data/a11/gsi/ && source build/envsetup.sh; lunch crosshatch-userdebug; cd $ANDROID_PRODUCT_OUT && rm sdk_image.zip; rm *.img; croot && make -j$(nproc --all) && cd $ANDROID_PRODUCT_OUT && cp product-qemu.img product.img && cp ramdisk-qemu.img ramdisk.img && cp system-qemu.img system.img && cp system_ext-qemu.img system_ext.img && cp vendor-qemu.img vendor.img ; zip -1 sdk_image.zip cache.img ramdisk.img system.img userdata.img vbmeta.img vendor.img && croot && cd /data/kernel_build/a11-5.4-stable
```



# Pack & Unpack

> https://bbs.kanxue.com/thread-252630.htm FART: 整体壳的缺点，FART
>
> https://bbs.kanxue.com/thread-254555.htm 拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点

- app脱壳本质是对内存中处于解密状态的dex的dump。这里脱壳指的是对加固apk中保护的dex的整体的dump。然后对脱下来的明文dex做修复

```java

  > handleMessage switch (msg.what) case BIND_APPLICATION:
    > handleBindApplication(AppBindData data)
      > getPackageInfoNoCheck 创建 LoadedApk
      > final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
			> mInstrumentation = new Instrumentation()
      > mInitialApplication = app = data.info.makeApplication(data.restrictedBackupMode, null); 创建 Application 对象
        > app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);
          > Application app = (Application)clazz.newInstance(); app.attach(context);
            > frameworks/base/core/java/android/app/Application.java Application.attach(Context context)
              > attachBaseContext(context); // 获取执行权进行代码执行
      > installContentProviders(app, data.providers); 安装providers
      > mInstrumentation.callApplicationOnCreate(app); 执行Application.Create回调
        > Application.onCreate(); // 获取执行权进行代码执行
```

> handleBindApplication: 启动一个application，将收集的apk组件等信息绑定在application里，app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的。加固工具常通过替换app入口Application，实现attachBaseContext和onCreate两个函数，进行代码的脱壳和执行权交付

- 壳在attachBaseContext, onCreate执行加密的dex的解密
- 通过自定义的ClassLoader在内存中加载解密后的dex文件
- 利用java反射，修复解密后的dex的Class和Method，如 ClassLoader, Application。通过反射修复应用运行中的ClassLoader，使得应用能够正常加载并调用dex中的类和方法，否则因为双亲委派，会报ClassNotFound。所有应用中加载的dex文件最终都在应用的ClassLoader中

> 因此，只要获取到加固应用最终通过反射设置后的ClassLoader，就可以通过一系列反射最终获取当前应用所加载的解密后的内存中的dex文件。即，dex整体加固可以用内存dump来得到原始dex

指令抽取型壳：为对抗dex整体壳容易被内存dump的问题，通过hook dex文件中的class, method加载执行过程中的关键流程，实现在函数执行前才进行解密的指令抽取的解决方案。由于函数体中的指令被加密，dex整体dump的方法无法对相关的函数进行脱壳。Fupk3通过欺骗壳而主动调用dex中各个函数，完成调用，让壳主动解密对应method的指令区域，完成对指令抽取型壳的脱壳。

## FART(ext)

> https://bbs.kanxue.com/thread-268760.htm
>
> https://github.com/dqzg12300/FartExt FartExt
>
> 基于主动调用来抽取壳的方案。在进程启动的时候通过双亲委派机制遍历所有classloader，然后遍历里面的所有class，取出所有函数，直接调用。然后在ArtMethod的Invoke函数这里根据参数判断出这是主动调用触发的，然后就取消函数的正常执行，并执行脱壳操作

1. 内存中DexFile结构体完整dex的dump
2. 主动调用类中每一个方法，实现对应CodeItem的dump
3. 主动调用dump下来的方法的CodeItem进行dex中被抽取的方法的修复



- dump DexFile: 因为壳通过替换APP的Application类并自己实现attachBaseContext和onCreate实现dex的解密加载，hook系统中的Class和Method加载执行流程中的关键函数，最后通过反射完成关键变量（如最终的ClassLoader, Application等）的替换，完成执行权的交付。所以可以选在Application的onCreate之后才被调用的任意一个函数。FART选择在 frameworks/base/core/java/android/app/ActivityThread.java 的 `performLaunchActivity`，获取最终App的ClassLoader中的mCookie，即native层的DexFile

```java
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
```

> 通过一系列反射，获取当前ClassLoader中的mCookie，即Native层中的DexFile

改进：使用art里面的`ClassLinker::LoadClassMembers`. FART通过运行过程中ArtMethod来使用GetDexFile函数从而获取DexFile引用达成dump dex目的

```cpp
void ClassLinker::LoadClassMembers(Thread* self,
                                   const DexFile& dex_file, // 包含对当前处理的dex的DexFile对象的引用，可以以此确定dex起始地址
                                   const uint8_t* class_data,
                                   Handle<mirror::Class> klass, bool dump) {
    LoadMethod(dex_file, it, klass, method);
```

```cpp
void ClassLinker::LoadMethod(const DexFile& dex_file,
                             const ClassDataItemIterator& it,
                             Handle<mirror::Class> klass,
                             ArtMethod* dst) { // 通过指针访问内存中的dexFile，获取ArtMethod所需内容后完成对ArtMethod的初始化
  dst->SetDexMethodIndex(dex_method_idx);
  dst->SetDeclaringClass(klass.Get());
  dst->SetCodeItemOffset(it.GetMethodCodeItemOffset()); // 对当前函数所指向的内存中的smali指令的地址进行了初始化
```

函数抽取类壳的两种策略：

- 提前将dex中的函数体进行加密或者直接置为无效。在函数执行前再进行该部分空间的解密从而供函数调用执行
- 在加固过程中对dex进行重构，导致原有函数体空间无效，函数执行前修改该ArtMethod对象中的CodeItemOffset指向，来达成函数的调用执行

```cpp
// 更详细全面的调用链可以看 ART Progress
> ClassLinker::DefineClass
  > ClassLinker::LoadClass
    > LoadClassMembers
      > LoadMethod
      > LinkCode
```

> Dex Dump思路
>
> - 修改aosp源码，在dump点插入dump整体dex的代码
> - frida hook对应函数，通过指针，定位内存中dex的起始点
> - ida过反调试后，在这些函数下断
> - xposed等，结合native hook

### dump CodeItem

构造一个invoke方法，调用ArtMethod的invoke方法，完成主动调用，在ArtMethod.invoke中，如果发现是主动调用，则进行方法体的dump并返回，完成对壳的欺骗，达到方法体的dump

有些抽取壳，执行到invoke时依然没有还原函数，必须在函数执行了之后，才会还原出真实的函数。

> https://bbs.kanxue.com/thread-268760.htm

- 如果是主动调用并且第一个指令如果不是GOTO的。就直接脱壳并结束
- 如果是主动调用并且第一个指令是GOTO的。让他继续执行
- 如果第三个指令是INVOKE-STATIC的执行完后直接结束掉

- Method Repair: 对前两步生成的文件，使用python脚本进行复原



### FartExt Src

```bash
# config /data/local/tmp/fext.config

# === art:


# === frameworks/base:

# === Fartext.java: frameworks/base/core/java/cn/mik/Fartext.java

```



### Fart src

```bash

> ArtMethod::Invoke : if (Thread* self == nullptr)
  > fart: ArtMethod::dumpArtMethod
    获取app_name，硬编码或读/data/fart
    
> fart: DexFile_dumpMethodCode dumpMethodCode
  for each direct / virutal method
  > fart: myfartInvoke

> frameworks/base/core/java/android/app/ActivityThread.java: handleBindApplication(AppBindData data)
  if(config.load() &&  config.mTargetPackage.equals(data.info.getPackageName())) # 创建.lock文件，判断config包名是否对应
  > new Fart(config.mTargetPackage,config.dumpCode).unpackAfter(10000)
    > unpackNow : for each dexfiles
      this.dumpMethodCode_method.invoke(this.dexfiles[i], ...);
      > DexFile_dumpMethodCode
        for (auto& dex_file : dex_files) 
        > # Dump dex to /data/data/xxx/123.dex
        
```

```bash
core/java/android/app/fart/UpkConfig.java UpkConfig 负责读取配置文件，确定需要脱壳的apk
# /data/fart format,first line is package name,  second line enables insns dump
pkg.name # change this
do_dump_code
# how to write inside adb shell # e.g.
echo "com.pshop" > /data/fart
echo "do_dump_code" >> /data/fart
```

